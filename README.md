# GTK-List-ManifestDB-From-iOSBackup
Read and extract files from iOS backup made by iTunes ( C++ / Linux / Gnome / GTK / gtkmm )

Program for parsing an iOS Backup generated by iTunes for iPad and iPhone</br>
( See what is covered under the hood of iOS )

While working under Fedora Linux I choose C++ as the programming language in combination with GTK and the gtkmm wrapper. With these you have excellent tools for developing own programs.

The normal procedure for building the program is using the standard autotools. The following sequence
```
./autogen.sh --prefix=$HOME/.local
make
make install
manifestDBview.sh
```
will build and run the program for the current user. The Linux way of localization can be adapted.

Alternatively (for all supported languages) you can easily compile and run the program in Terminal with the added shell script:
```
sh ./GTKManifestDBView.sh
```

The program follows the design of the earlier program List-ManifestDB-From-iOSBackup written in Swift (published in my repository). Since I switched from macOS to Fedora Linux (for what reasons ever) I had to change my programming language. For "simplicity" I choose C++ and to my pleasure found its "way to think" very similar to Swift and Objective-C. In some aspects I found C++ in combination with GTK easier compared to Swift ...

I wrote this program to become familiar with the C++ language, especially the GTK-API under the gtkmm wrapper and to get a feeling how to display multiple widgets on the screen. Take it as example for handling of windows, boxes, comboboxes, treeviews, textviews and more.

I am using a variadic function (handover of a variable amount of arguments) to compose display status messages in an extra TextView. The code for this is originated from</br>
<https://stackoverflow.com/questions/21806561/concatenating-strings-and-numbers-in-variadic-template-function>

I modified it for my needs ...

### Background:
The file Manifest.mbdb describes no longer the backup files for iOS. Beginning with iTunes version 12.5 (or so) the main information for the files is stored in a SQLite database Manifest.db. iTunes as of macOS Sierra is using this scheme in any case.

The structure of this database is as follows 
```
$ sqlite3
sqlite> .open Manifest.db
sqlite> .fullschema
CREATE TABLE Files (fileID TEXT PRIMARY KEY, domain TEXT, relativePath TEXT, flags INTEGER, file BLOB);
CREATE INDEX FilesDomainIdx ON Files(domain);
CREATE INDEX FilesRelativePathIdx ON Files(relativePath);
CREATE INDEX FilesFlagsIdx ON Files(flags);
CREATE TABLE Properties (key TEXT PRIMARY KEY, value BLOB);
.quit
```
Access to SQLite under C++ was realized analogous to the first answer at</br>
&nbsp; <http://stackoverflow.com/questions/24102775/accessing-an-sqlite-database-in-swift>

Since the reading of BLOBs (binary large objects) is tricky, here follows a snippet of my source code:
```
    struct FileInfo {
        Glib::ustring fileID = "";
        // depending of domain display belonging fileID, relative path and flags
        Glib::ustring domain = ""; 
        Glib::ustring relativePath = ""; 
        long flags = 0;
        // BLOB: binary large object
        std::vector<unsigned char>* fileBlob;
    };
    vector<FileInfo*> backupItems = {};
...
    while (sqlite3_step(stmt) == SQLITE_ROW) {
        FileInfo* fileInfo = new FileInfo;
        basic_string<unsigned char> item1 = sqlite3_column_text(stmt, 0);
        fileInfo->fileID = string(item1.begin(), item1.end());
        basic_string<unsigned char> item2 = sqlite3_column_text(stmt, 1);
        fileInfo->domain = string(item2.begin(), item2.end());
        basic_string<unsigned char> item3 = sqlite3_column_text(stmt, 2);
        fileInfo->relativePath = string(item3.begin(), item3.end());
        fileInfo->flags = sqlite3_column_int64(stmt, 3);
        const unsigned char* blob = \
          reinterpret_cast<const unsigned char*>(sqlite3_column_blob(stmt, 4));
        // Get the number of blob bytes
	int blob_bytes = sqlite3_column_bytes(stmt, 4);
        // new vector of blob_bytes size + 2 for quotes
        std::vector<unsigned char>* file_blob = new std::vector<unsigned char>(blob_bytes+2);
        # insert leading quote
        (*file_blob)[0] = '\"';
        // copy blob data into vector
        //std::copy(blob, blob + blob_bytes, &((*file_blob)[1]));
        std::copy(blob, blob + blob_bytes, &(file_blob->at(1)));
        # insert trailing quote
        (*file_blob)[blob_bytes+1] = '\"';
        fileInfo->fileBlob = file_blob;
        backupItems.push_back(fileInfo);
    }
```
Use the program for extracting of backuped files which could not be recovered otherwise.

### Usage:
Click on "Open" left in the toolbar above to open an appropiate data base file. The Backup is structured in so-called domains. Down right there is now appearing a button "Export CSV...". Clicking will export the data base structure to an ';' separated CSV file, which can be read in a text editor or calculation program of your choice. Choosing a domain from the appearing Combobox will display further components of this domain. Double-clicking a row in the table opens a dialog where you can select the place for storing the requested file. If you know which domain entry you are looking for, enter a significant beginning of the text in the entry field of the combobox and press ENTER. The first entry which will match is then selected. So typing in 'CameraRoll' will fetch the CameraRollDomain, where you find your stored images. Quit the program with "Quit" or closing the application window.

### Acknowledgements:
- David Blache for some fundamentals about iOSBackup and his idea to export a CSV file.</br>
<https://www.quora.com/How-do-I-access-and-read-a-file-from-my-iPhone-backup-on-my-PC>
- Marnix Kaart for an excellent python solution.</br>
<https://github.com/mx-pycoder/pearback>
- Special thanks go to the people in the developer community at StackOverflow. Without their help and answered questions at <https://stackoverflow.com/> and affiliate sites this work would not be possible.

### Disclaimer:
Use the program for what purpose you like, but hold in mind, that I will not be responsible for any harm it will cause to your hard- or software. It was your decision to use this piece of software.
